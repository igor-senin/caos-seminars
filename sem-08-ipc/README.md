# IPC, Inter Process Communication

Какие методы общения между процессами мы уже знаем? Сегодня рассматриваем процессы, созданные классическим `fork`.

* Процесс A пишет в файл, процесс B считывает из файла.
* Передача аргументов командной строки / переменных окружения при `fork`+`exec`.
* Разделяемая память (см. `mmap`).

Пришло время познакомиться с настоящим межпроцессным взаимодействием.

## Дублирование файловых дескрипторов

В следующих примерах нам нужно будет перенаправлять данные из одного файлового дескриптора в другой. Вы могли встречаться с такой ситуацией в bash:
```bash
cat file.txt > file.out
```
Мы не можем контролировать поведение программы `cat`, она всегда пишет в свой `STDOUT_FILENO`, т.е. `write(1, buf, len)`. Но в данном случае мы хотим (как командная оболочка):

1. Сделать `fork` для выполнения команды
2. Открыть `file.out` на запись
3. *Перенаправить* `stdout` в `file.out`
4. Выполнить `exec*("cat file.txt")`

Поскольку при `exec` файловые дескрипторы родителя наследуются ребёнку, `cat` при `write(1, ...)` будет на самом деле писать в `file.out`.

Такой функционал реализуется семейством системных вызовов `dup*`:
```c
/*
Создаёт и возвращает файловый дескриптор, ссылающийся на ту же
дескрипцию открытого файла, что и oldfd.
Новый дескриптор гарантированно будет наименьшим неиспользованным в программе.
*/
int dup(int oldfd);

/*
Создаёт дубликат файлового дескриптора oldfd, используя
номер дескриптора, указанный в newfd.
Если newfd уже открыт, dup2 сначала закрывает его.
*/
int dup2(int oldfd, int newfd);
int dup3(int oldfd, int newfd, int flags);
```

Стоит отметить, что такие файловые дескрипторы делят общее смещение в файле (`lseek` по одному дескриптору видно в другом), а также большинство флагов открытых файлов.

Простой пример на применение `dup2` находится в файле [dup.c](dup.c).

## Пайпы

Правильное название пайпов - **неименнованные каналы**. Канал - это пара связанных между собой файловых дескрипторов, один из которых предназначен только для чтения, а второй - только для записи.

```c
/*
Создаёт канал и записывает файловый дескриптор
читающего конца в 0-й элемент массива,
а пишущего конца в 1-й элемент массива.
*/
int pipe(int pipefd[2]);
```

Концы пайпа в программе представлены теми же *файловыми дескрипторами*, поэтому большинство работы с пайпом осуществляется через знакомые нам системные вызовы `read` и `write`.

**Важно**: чтение из пайпа и запись в пайп - **блокирующие** в общем случае операции. Операция называется **блокирующей**, если процесс в ходе её выполнения переходит в состояние interruptable / uninterruptable сна. Иными словами, на какое-то (может быть, значительное) время перестает планироваться на выполнение планировщиком ОС. Другой знакомый нам пример блокирующей операции - `wait`.

С помощью системного вызова `fcntl` работу с файловым дескриптором можно сделать неблокирующей (см. пример в [pipes/pipe.c](pipes/pipe.c)).

Канал буфферизован; размер буффера, как правило, 64KiB. Если в буффере недостаточно места для записи, то процесс блокируется на `write` (см. [pipes/pipe.c](pipes/pipe.c) и [pipes/pipe_buf.c](pipes/pipe_buf.c)).

При этом:
* если на читающем конце нет ни одного читателя, ядро пошлёт процессу сигнал `SIGPIPE`, а `write` завершится с `errno=EPIPE`
* если на пишущем конце нет ни одного писателя, то читатель сначала будет вычитывать данные из канала; когда данные иссякнут, `read` вернёт 0

Пользуясь этими фактами, можно написать странный, но рабочий метод синхронизации процессов: процесс A оставляет конец для записи пайпа открытым и запускает долгое вычисление; процесс B блокируется на чтении из пайпа (см. [pipes/child_waiting.c](pipes/child_waiting.c)).

## Сигналы

**Сигнал** - короткое асинхронное сообщение процессу. Асинхронные, потому что с точки зрения приложения невозможно предугадать, когда придёт сигнал. Список всех стандартных сигналов представлен в [man signal.7](https://man7.org/linux/man-pages/man7/signal.7.html).

Каждому сигналу соответствует номер больше нуля, но на разных UNIX-системах эти номера могут отличаться. Поэтому в коде следует использовать символические названия, типа `SIGKILL`, которые определены в `signal.h`.

Отправителями сигналов могут быть:
* Ядро -
    * в ответ на недопустимые действия с железом, например, деление на ноль инициирует хардверное прерывание [#DE](https://www.felixcloutier.com/x86/div#64-bit-mode-exceptions), которое ядро преобразует в сигнал SIGFPE; нарушение прав доступа при обращении к памяти вызывает прерывание [#GP](https://wiki.osdev.org/Exceptions#General_Protection_Fault), которое на большинстве платформ превратится в SIGSEGV
    * в ответ на софтверные события, например, когда завершается потомок процесса, родителю отправляется сигнал SIGCHLD
* Процесс сам себе - SIGABRT при вызове [abort()](https://man7.org/linux/man-pages/man3/abort.3.html) или SIGALRM по истечении таймера, [alarm()](https://man7.org/linux/man-pages/man2/alarm.2.html).
* Сторонний процесс - почти любой сигнал, если у процесса есть на это права (было бы глупо, если бы непривелегированный процесс умел убивать systemd).

Некоторые сигналы можно отправить через терминал сочетанием клавиш:
* `Ctrl+C` - отправляет процессу SIGINT
* `Ctrl+Z` - SIGTSTP
* `Ctrl+\` - SIGQUIT

Диспозиция по умолчанию, хэндлеры, signal.

Отправление и доставка сигналов, маски, blocked и pending.

Сигналы не встают в очередь, порядок доставки не гарантируется (примеры)

Real-time сигналы, sigaction

## Именованные каналы

TBD
