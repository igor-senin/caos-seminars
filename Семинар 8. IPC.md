# IPC, Inter Process Communication

Какие методы общения между процессами мы уже знаем? Сегодня рассматриваем процессы, созданные классическим `fork`.

* Процесс A пишет в файл, процесс B считывает из файла.
* Передача аргументов командной строки / переменных окружения при `fork`+`exec`.
* Разделяемая память (см. `mmap`).

Пришло время познакомиться с настоящим межпроцессным взаимодействием.

## Дублирование файловых дескрипторов

В следующих примерах нам нужно будет перенаправлять данные из одного файлового дескриптора в другой. Вы могли встречаться с такой ситуацией в bash:
```bash
cat file.txt > file.out
```
Мы не можем контролировать поведение программы `cat`, она всегда пишет в свой `STDOUT_FILENO`, т.е. `write(1, buf, len)`. Но в данном случае мы хотим (как командная оболочка):

1. Сделать `fork` для выполнения команды
2. Открыть `file.out` на запись
3. *Перенаправить* `stdout` в `file.out`
4. Выполнить `exec*("cat file.txt")`

Поскольку при `exec` файловые дескрипторы родителя наследуются ребёнку, `cat` при `write(1, ...)` будет на самом деле писать в `file.out`.

Такой функционал реализуется семейством системных вызовов `dup*`:
```c
/*
Создаёт и возвращает файловый дескриптор, ссылающийся на ту же
дескрипцию открытого файла, что и oldfd.
Новый дескриптор гарантированно будет наименьшим неиспользованным в программе.
*/
int dup(int oldfd);

/*
Создаёт дубликат файлового дескриптора oldfd, используя
номер дескриптора, указанный в newfd.
Если newfd уже открыт, dup2 сначала закрывает его.
*/
int dup2(int oldfd, int newfd);
int dup3(int oldfd, int newfd, int flags);
```

Стоит отметить, что такие файловые дескрипторы делят общее смещение в файле (`lseek` по одному дескриптору видно в другом), а также большинство флагов открытых файлов.

TODO: примеры.

## Пайпы

Правильное название пайпов - **неименнованные каналы**. Канал - это пара связанных между собой файловых дескрипторов, один из которых предназначен только для чтения, а второй - только для записи.

```c
/*
Создаёт канал и записывает файловый дескриптор
читающего конца в 0-й элемент массива,
а пишущего конца в 1-й элемент массива.
*/
int pipe(int pipefd[2]);
```

Концы пайпа в программе представлены теми же *файловыми дескрипторами*, поэтому большинство работы с пайпом осуществляется через знакомые нам системные вызовы `read` и `write`.

**Важно**: чтение из пайпа и запись в пайп - **блокирующие** в общем случае операции. Операция называется **блокирующей**, если процесс в ходе её выполнения переходит в состояние interruptable / uninterruptable сна. Иными словами, на какое-то (может быть, значительное) время перестает планироваться на выполнение планировщиком ОС. Другой знакомый нам пример блокирующей операции - `wait`.

Канал буфферизован; размер буффера, как правило, 64KiB. Если в буффере недостаточно места для записи, то процесс блокируется на `write`.

При этом:
* если на читающем конце нет ни одного читателя, ядро пошлёт процессу сигнал `SIGPIPE`, а `write` завершится с `errno=EPIPE`
* если на пишущем конце нет ни одного писателя, то читатель сначала будет вычитывать данные из канала; когда данные иссякнут, `read` вернёт 0

TODO: пример

## Сигналы

TBD

## Именованные каналы

TBD